SELECT * FROM CARS

SELECT * FROM OWNERS
 
CREATE TABLE CARS(

	C_ID PRIMARY KEY IDENTITY(1, 1),

	O_ID INT, 

	FOREIGN KEY(O_ID) REFERENCES OWNERS(O_ID)

)
 
--Use the INNER JOIN syntax because it is more explicit, readable, and maintainable. It clearly indicates that a join is happening and is easier to manage, especially when working with multiple tables or complex queries.

--The **WHERE clause** join syntax is outdated and works in basic cases, but for clarity, it's better to use the more modern INNER JOIN` or other explicit join types.
 
--SHOW THE NAME OF THE OWNER AND CAR NAME, PRICE

SELECT OWNERS.SNAME, CARS.BRAND, CARS.PRICE

FROM CARS INNER JOIN OWNERS

ON CARS.OID = OWNERS.OID;
 
--DON'T USE THIS - UNCLEAR

SELECT OWNERS.SNAME, CARS.BRAND, CARS.PRICE

FROM CARS, OWNERS

WHERE CARS.OID = OWNERS.OID;
 
--RIGHT + LEFT (ONLY MATCHING) ALSO LEFT OUTER JOIN

SELECT OWNERS.SNAME, CARS.BRAND, CARS.PRICE

FROM CARS RIGHT JOIN OWNERS

ON CARS.OID = OWNERS.OID;
 
--LEFT + RIGHT (ONLY MATCHING)  ALSO LEFT OUTER JOIN

SELECT OWNERS.SNAME, CARS.BRAND, CARS.PRICE

FROM CARS LEFT JOIN OWNERS

ON CARS.OID = OWNERS.OID;
 
SELECT OWNERS.SNAME, CARS.BRAND, CARS.PRICE

FROM CARS FULL JOIN OWNERS

ON CARS.OID = OWNERS.OID;
 
--A CROSS JOIN returns the Cartesian product of two tables, i.e., it combines every row from the first table with every row from the second table.

SELECT OWNERS.SNAME, CARS.BRAND, CARS.PRICE

FROM CARS CROSS JOIN OWNERS
 
--NATURAL JOIN: Joins tables based on matching columns (same name and compatible data types) without needing to explicitly specify the join condition.

SELECT OWNERS.SNAME, CARS.BRAND, CARS.PRICE

FROM CARS NATURAL JOIN OWNERS
 
SELECT * FROM CARS

SELECT * FROM OWNERS
 
SELECT O.SNAME, C.BRAND, C.PRICE

FROM OWNERS O LEFT JOIN CARS C

ON O.OID = C.OID

WHERE C.PRICE > 100000
 
SELECT O.SNAME, C.BRAND, C.PRICE

FROM OWNERS O LEFT JOIN CARS C

ON O.OID = C.OID

WHERE PRICE IS NULL
 
SELECT O.SNAME, SUM(C.PRICE) AS CARS_PRICE FROM OWNERS O INNER JOIN CARS C 

ON O.OID = C.OID

 
 
SELECT * FROM CARS
SELECT * FROM OWNERS
SELECT O.SNAME, C.BRAND, C.PRICE
FROM OWNERS O LEFT JOIN CARS C
ON O.OID = C.OID
WHERE C.PRICE > 100000
SELECT O.SNAME, C.BRAND, C.PRICE
FROM OWNERS O LEFT JOIN CARS C
ON O.OID = C.OID
WHERE PRICE IS NULL
SELECT O.SNAME, SUM(C.PRICE) AS CARS_PRICE FROM OWNERS O INNER JOIN CARS C 
ON O.OID = C.OID
GROUP BY O.SNAME
SELECT SUM(PRICE) AS TOTAL_SALES, COUNT(*) AS COUNT,
SUBSTRING(REG_NO, 1, 3) AS state
FROM cars
GROUP BY SUBSTRING(REG_NO, 1, 3)
ORDER BY STATE;
SELECT SUBSTRING(REG_NO, 1, 3) AS STATE, COUNT(*) AS SALES
FROM CARS
GROUP BY SUBSTRING(REG_NO, 1, 3);
 
 
SELECT C.FIRSTNAME, C.LASTNAME, O.ORDERDATE, O.ORDERNUMBER, OI.QUANTITY * OI.UNITPRICE AS TOTAL, P.PRODUCTNAME, S.COMPANYNAME 
FROM CUSTOMERS_JIBE2 C
INNER JOIN ORDERS_JIBE2 O ON C.ID = O.CUSTOMERID
INNER JOIN ORDERITEMS_JIBE2 OI ON OI.ORDERID = O.ID
INNER JOIN PRODUCTS_JIBE2 P ON P.ID = OI.PRODUCTID
INNER JOIN SUPPLIERS_JIBE2 S ON S.ID = P.SUPPLIERID
WHERE C.ID = 1
 
 
SELECT
 M.NAME AS MANAGER_NAME
 FROM EMPLOYEE_JIBE E
RIGHT JOIN EMPLOYEE_JIBE M
 ON E.MGR_ID = M.EMP_ID
WHERE E.NAME IS NULL
 
 
SELECT * FROM EMPLOYEE_JIBE 
SELECT * FROM CUSTOMERS_JIBE
SELECT NAME, LASTNAME FROM EMPLOYEE_JIBE 
INTERSECT
SELECT FIRSTNAME, LASTNAME FROM CUSTOMERS_JIBE
SELECT NAME, LASTNAME FROM EMPLOYEE_JIBE 
UNION 
SELECT FIRSTNAME, LASTNAME FROM CUSTOMERS_JIBE
SELECT NAME, LASTNAME FROM EMPLOYEE_JIBE 
UNION ALL
SELECT FIRSTNAME, LASTNAME FROM CUSTOMERS_JIBE
SELECT NAME, LASTNAME FROM EMPLOYEE_JIBE 
EXCEPT
SELECT FIRSTNAME, LASTNAME FROM CUSTOMERS_JIBE
SELECT STANDARD, COUNT(*) FROM STUDENTS_JIBE
GROUP BY STANDARD
ORDER BY STANDARD
SELECT STANDARD, CT FROM CTE
UNION 
SELECT '--------------', 0
UNION
SELECT 'HIGHEST', MAX(CT) FROM CTE
UNION
SELECT 'LOWEST', MIN(CT) FROM CTE
UNION
SELECT 'AVERAGE', AVG(CT) FROM CTE

 select * from student_jibe
where english > 
(
	select english from student_jibe
	where roll = 100
)

select * from student_jibe

select standard, count(*) as count 
from student_jibe
group by standard
having count(*) > (
	select count(*) from student_jibe 
	where standard = 4
)

select roll, sname, english+maths+science as total from student_jibe 
where english+maths+science > (
		select max(english+maths+science) as maximum from student_jibe
		where standard = 5
	)
	and standard = 6

select * from student_jibe
where standard = 6
	and english > any
	(
		select min(english) from student_jibe
		where standard = 5
	)

select * from student_jibe
where standard = 6
	and english > any
	(
	 select english from student_jibe
	 where standard = 5
	)

SELECT OID FROM CARS


SELECT DISTINCT(OID) FROM CARS
WHERE OID IS NOT NULL

SELECT * FROM OWNERS
WHERE OID IN (
		SELECT DISTINCT(OID) FROM CARS
		WHERE OID IS NOT NULL
	)

SELECT * FROM OWNERS
WHERE OID NOT IN (
		SELECT DISTINCT (OID) FROM CARS
		WHERE OID IS NOT NULL
	)


SELECT STANDARD, RESULT, COUNT(*) FROM 
(
 SELECT STANDARD,
	CASE 
		WHEN ISNULL(ENGLISH, 0) + MATHS + SCIENCE >= 100 THEN 'PASS'
	ELSE 'FAIL' END AS RESULT
	FROM STUDENT_JIBE
) AS T
GROUP BY STANDARD, RESULT
ORDER BY STANDARD, RESULT

SELECT * FROM STUDENT_JIBE
WHERE MATHS = (
	SELECT MAX(MATHS) FROM STUDENT_JIBE
)

SELECT * FROM STUDENT_JIBE S
WHERE MATHS > (
	SELECT AVG(MATHS) FROM STUDENT_JIBE
	WHERE STANDARD = S.STANDARD
)	

SELECT * FROM STUDENT_JIBE S
WHERE MATHS > (
	SELECT AVG(MATHS) FROM STUDENT_JIBE
	GROUP BY STANDARD
	HAVING AVG(MATHS) > S.MATHS
)

SELECT SNAME, MATHS, S.STANDARD 
FROM STUDENT_JIBE S 
INNER JOIN (
	SELECT STANDARD, CAST(AVG(MATHS) AS DECIMAL(5,2)) AS AV
	FROM STUDENT_JIBE 
	GROUP BY STANDARD 
) AS T ON S.STANDARD = T.STANDARD 
WHERE S.MATHS > T.AV
WITH CTE AS (
	SELECT STANDARD, CAST(AVG(MATHS) AS DECIMAL(5,2)) AS AV
	FROM STUDENT_JIBE
	GROUP BY STANDARD 
)

SELECT SNAME, MATHS, S.STANDARD 
FROM STUDENT_JIBE 





SELECT C.FIRSTNAME, C.LASTNAME, O.ORDERDATE, O.ORDERNUMBER, OI.QUANTITY * OI.UNITPRICE AS TOTAL, P.PRODUCTNAME, S.COMPANYNAME 
FROM CUSTOMERS_JIBE2 C
INNER JOIN ORDERS_JIBE2 O ON C.ID = O.CUSTOMERID
INNER JOIN ORDERITEMS_JIBE2 OI ON OI.ORDERID = O.ID
INNER JOIN PRODUCTS_JIBE2 P ON P.ID = OI.PRODUCTID
INNER JOIN SUPPLIERS_JIBE2 S ON S.ID = P.SUPPLIERID
WHERE C.ID = 1

SELECT distinct(S.COMPANYName)
FROM CUSTOMERS_JIBE2 C
INNER JOIN ORDERS_JIBE2 O ON C.ID = O.CUSTOMERID
INNER JOIN ORDERITEMS_JIBE2 OI ON OI.ORDERID = O.ID
INNER JOIN PRODUCTS_JIBE2 P ON P.ID = OI.PRODUCTID
INNER JOIN SUPPLIERS_JIBE2 S ON S.ID = P.SUPPLIERID
WHERE s.COUNTRY = 'USA'
AND C.COUNTRY = 'GERMANY';

--NOT BROUGHT ANYTING
SELECT distinct(c.firstName)
FROM CUSTOMERS_JIBE2 C
LEFT JOIN ORDERS_JIBE2 O ON C.ID = O.CUSTOMERID
WHERE O.ID IS NULL

CREATE INDEX IDX_ORDERID ON ORDERITEMS_JIBE2(ORDERID ASC)

select * from employee_jibe

select e.name as employee_name, m.name as manager_name
from employee_jibe e inner join employee_jibe m
on e.mgr_id = m.emp_id;



SELECT
	STRING_AGG(e.name,',') AS EMPLOYEE_JIBEs,
	m.name as manager_name
From EMPLOYEE_JIBE e
INNER JOIN EMPLOYEE_JIBE m
	ON e.mgr_id = m.emp_id
GROUP BY m.name;

SELECT
	STRING_AGG(e.name,',') AS EMPLOYEE_JIBEs,
	m.name as manager_name
From EMPLOYEE_JIBE e
INNER JOIN EMPLOYEE_JIBE m
	ON e.mgr_id = m.emp_id
GROUP BY m.name;

SELECT
	M.NAME AS MANAGER_NAME
	FROM EMPLOYEE_JIBE E
RIGHT JOIN EMPLOYEE_JIBE M
	ON E.MGR_ID = M.EMP_ID
WHERE E.NAME IS NULL

select * from cars;
select * from owners;

--Joins
--brings only data that matches
select owners.sname , cars.brand, cars.price
from cars inner join owners
on cars.oid = owners.oid;

select owners.sname , cars.brand, cars.price
from owners left join cars
on cars.oid = owners.oid;

select owners.sname , cars.brand, cars.price
from owners right join cars
on cars.oid = owners.oid;

select owners.sname , cars.brand, cars.price
from owners full join cars
on cars.oid = owners.oid;

select owners.sname, cars.brand, cars.price
from owners cross join cars;

SELECT owners.sname, cars.brand
FROM owners 
LEFT JOIN cars ON owners.oid = cars.oid -- Don't forget the "ON"!
WHERE cars.price > 1000000;

SELECT owners.sname, cars.brand
FROM owners 
LEFT JOIN cars ON owners.oid = cars.oid -- Don't forget the "ON"!
WHERE cars.price is null;


SELECT o.sname, cars.brand
FROM owners o
LEFT JOIN cars ON owners.oid = cars.oid -- Don't forget the "ON"!
WHERE cars.price is null;

select * from student_jibe

SELECT 
    sname, 
    english,
    ROUND(AVG(maths) OVER (
        ORDER BY roll
        ROWS BETWEEN 4 PRECEDING AND CURRENT ROW
    ), 2) AS moving_avg_4
FROM student_jibe
WHERE standard = 5 
  AND division = 'A';


  SELECT 
    sname, 
    english,
    ROUND(AVG(maths) OVER (
        ORDER BY roll
        ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
    ), 2) AS running_total
FROM student_jibe
WHERE standard = 5 AND division = 'A';

SELECT * FROM EMPLOYEE_JIBE 
SELECT * FROM CUSTOMERS_JIBE

SELECT NAME, LASTNAME FROM EMPLOYEE_JIBE 
INTERSECT
SELECT FIRSTNAME, LASTNAME FROM CUSTOMERS_JIBE

SELECT NAME, LASTNAME FROM EMPLOYEE_JIBE 
UNION 
SELECT FIRSTNAME, LASTNAME FROM CUSTOMERS_JIBE

SELECT NAME, LASTNAME FROM EMPLOYEE_JIBE 
UNION ALL
SELECT FIRSTNAME, LASTNAME FROM CUSTOMERS_JIBE

SELECT NAME, LASTNAME FROM EMPLOYEE_JIBE 
EXCEPT
SELECT FIRSTNAME, LASTNAME FROM CUSTOMERS_JIBE

SELECT STANDARD, COUNT(*) FROM STUDENTS_JIBE
GROUP BY STANDARD
ORDER BY STANDARD

WITH CTE AS 
(
	SELECT CAST(STANDARD AS VARCHAR(2)) AS STANDARD, COUNT(*) AS CT FROM STUDENTS_JIBE
	GROUP BY STANDARD
)
SELECT STANDARD, CT FROM CTE
UNION
SELECT 'HIGHEST', MAX(CT) FROM CTE
UNION
SELECT 'LOWEST', MIN(CT) FROM CTE
UNION
SELECT 'AVERAGE', AVG(CT) FROM CTE

SELECT CAST(STANDARD AS VARCHAR(2)) AS STANDARD, COUNT(*) AS CT FROM STUDENT_JIBE
GROUP BY STANDARD
UNION
SELECT 'HIGHEST',
(
	SELECT MAX(CT) FROM 
	(
		SELECT COUNT(*) AS CT FROM STUDENT_JIBE
		GROUP BY STANDARD
	) AS T
)

CREATE VIEW PROTECTED_STUDENTS AS 
SELECT ROLL, SNAME, ENGLISH, MATHS, SCIENCE, STANDARD, DIVISION
FROM STUDENTS_JIBE

SELECT * FROM PROTECTED_STUDENTS

SELECT 
	t.name as table_name
	s.name as schema_name
from sys.tables t 
join sys.schemas s 
	on t.schema

select * from common_data





also explain ties
 
 
